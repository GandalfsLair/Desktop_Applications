<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>RESPONDER V3.1.4</title>
  <style>
    body {
      margin: 0;
      background: black;
      color: #00FF00;
      font-family: 'Courier New', Courier, monospace;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    #terminal {
      flex: 1;
      padding: 1em;
      overflow-y: auto;
      white-space: pre;
    }

    #input-line {
      border: none;
      outline: none;
      background: black;
      color: #00FF00;
      font-family: inherit;
      font-size: 1em;
      width: 100%;
    }
    .windows-prompt {
    color: white;
    font-family: 'Lucida Console', 'Courier New', monospace;
}

.windows-error {
    color: #FF5555;
}

.windows-path {
    color: #9CD9F0;
}

#input-line.windows-mode {
    color: white;
    background: #0C0C0C;
    padding-left: 0;
}

#input-line.windows-mode::before {
    content: "C:\\Windows\\System32> ";
    color: #9CD9F0;
    padding-right: 5px;
}
  </style>
</head>
<body>
  <div id="terminal"></div>
  <input id="input-line" placeholder="Enter command..." autofocus />

  <script>
    const terminal = document.getElementById("terminal");
    const inputLine = document.getElementById("input-line");

    //LOCAL CONSTANTS
    let isLocal = false; //DO NOT CHANGE THIS! This is needed for the WIPE command function.

    //LOG CONSTANTS
    let isRunning = false;
    let logInterval = null;
    let logFrequency = 3000; // Change this value to set log interval in ms

    //HOST CONSTANTS
    let hostIP = "192.168.10.4"; // IP addr that Responder is on
    let hostPort = "8080"; // Port that responder is sitting on

    //HOTKEY CONSTANTS
    let arpSpoof = "192.168.10.1 [ROUTER]"; //Thing being ARP Spoofed
    let arpInter = "eth0"; //ARP spoofing target interface
    let arpMac = "A1:B2:C3:D4:E5:F6"; //ARP spoofing target MAC address
    let targetUser ="j.smith"; //User whose credentials we got
    let targetCred = "Millwall1998"; //Credentials for targetUser
    let beaconVic = "137.42.10.22"; // IP where beacon traffic is going
    let beaconAtt = "192.168.10.12**"; // IP of the Beacon within the victims network

    //COMMAND CONSTANTS
    let scripts = "No Scripts Loaded at this Time."; // List of available scripts
    //let script_XXX = "SPECIFIC SCRIPT";
    let savePoint = "LocalHost//SHARED/DOC/TEMP"; //Location where data is 'saved' to. 
    let saveData = "temp_data.txt"; //Name of saved data file. 
    //LOG CONSTANTS

    const protocolsOrActivities = [
  "DNS", "HTTP", "HTTPS", "ARP", "SNMP", "DHCP", "RDP", "SMB", "LDAP",
  "New NetBIOS Name", "NBNS", "LLMNR", "WPAD"
];

const actions = [
  "query", "auth request", "sync request", "name request", 
  "packet", "broadcast", "hash", "beacon"
];

const directions = [
  "sent to", "received from", "intercepted from", "responded to",
  "captured from", "forwarded to", "relayed to"
];

const ipRanges = [
  "10.0.0.", "192.168.1.", "172.16.0.", "192.168.0.", "10.10.1."
];

const staticLogs = [
  "[+] Poisoned answer sent to 192.168.1.12 for *SMB*",
  "[+] New NetBIOS Name request from 10.0.0.7",
  "[+] Captured NTLMv2 hash from 10.0.0.5",
  "[+] HTTP Auth request intercepted from 172.16.0.4",
  "[!] WPAD rogue configuration sent",
  "[+] DNS query intercepted for 'corp.local'",
];

let recentLogs = [];

function getUniqueLog() {
  let log, attempts = 0;
  do {
    log = generateLogEntry();
    attempts++;
  } while (recentLogs.includes(log) && attempts < 5);

  // Add to recent logs and trim to last 10
  recentLogs.push(log);
  if (recentLogs.length > 10) recentLogs.shift();

  return log;
}

function getRandomLog() {
  const useGenerated = Math.random() < 0.7;
  return useGenerated ? getUniqueLog() : getRandomItem(staticLogs);
}

    //LOG ENTRIES ASSOCIATED WITH HOTKEYS
    const specialLog = `[+] CREDENTIAL DETECTED: Captured credentials from ${targetUser}@${hostIP} {${targetCred}}`; //KEYPRESS 'p'

    const warnLog = "[!] ALERT: Security measures now active!"; // KEYPRESS 'w'

    const beaconLog = `[!] BEACON: Beacon traffic detected. Source: ${beaconVic}. Destination: ${beaconAtt}`; // KEYPRESS 'b'

    const arpSpoofon = `[!] ALERT: ARP spoofing started on ${arpSpoof} [${arpMac} on ${arpInter}]`; // KEYPRESS '1'
    const arpSpoofoff = `[!] ALERT: ARP spoofing stopped on ${arpSpoof} [${arpMac} on ${arpInter}]`; // KEYPRESS '2'

    //LOG ENTRIES ASSOCIATED WITH COMMANDS


    function printToTerminal(text) {
    const escapedText = text.replace(/</g, '&lt;').replace(/>/g, '&gt;');
    terminal.innerHTML += escapedText + "\n";
    terminal.scrollTop = terminal.scrollHeight;
}

    function startLogs() {
      if (!isRunning) {
        isRunning = true;
        printToTerminal("[i] ADMIN FUNCTION: Process: Cached");
        printToTerminal("[i] ADMIN FUNCTION: memloc = FE13742");
        printToTerminal("[i] Responder started...");
        logInterval = setInterval(() => {
          const log = getRandomLog(); //Static and Random logs
          printToTerminal(log);
        }, logFrequency);
      }
    }

    function stopLogs() {
      if (isRunning) {
        clearInterval(logInterval);
        isRunning = false;
        printToTerminal("[i] Responder stopped.");
      }
    }

    function getRandomIP(range) {
  return range + Math.floor(Math.random() * 255);
}

function getRandomItem(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}

function generateLogEntry() {
  const A = getRandomItem(protocolsOrActivities);
  const B = getRandomItem(actions);
  const C = getRandomItem(directions);
  const D = getRandomIP(getRandomItem(ipRanges));

  return `[+] ${A} ${B} ${C} ${D}`;
}

    function handleCommand(cmd) {
    const lower = cmd.toLowerCase();
    
    // Handle special exit command (works in both modes but different behavior)
    if (cmd === '(run<rebind>={cache[memloc=FE13742]})') { // Exact match, no lowercase
        if (isLocal) {
            printToTerminal('C:\\Windows\\System32> Memory accessed... Thread Rebinding');
            setTimeout(() => {
                location.reload();
            }, 1000);
            return;
        } else {
            printToTerminal('[!] ADMIN FUNCTION: Memory location protected in current mode');
            return;
        }
    }
    
    if (isLocal) {
    // First check if it's our special command
    if (cmd === '(run<rebind>={cache[memloc=FE13742]})') {
        printToTerminal('C:\\Windows\\System32> Memory accessed... Thread Rebinding');
        setTimeout(() => location.reload(), 1000);
        return;
    }
    
    // Normal Windows mode processing for other commands
    printToTerminal(`C:\\Windows\\System32> ${cmd}`);
    printToTerminal(`'${cmd}' is not recognized as an internal or external command,`);
    printToTerminal(`operable program or batch file.`);
    printToTerminal('C:\\Windows\\System32> ');
    return;
}
    
    // Normal Responder mode processing
    printToTerminal(`> ${cmd}`);
    
    switch(lower) {

        case 'help':
          showHelp();
          break;
        case 'start':
          startLogs();
          break;
        case 'stop':
          stopLogs();
          break;
        case 'status':
          printToTerminal(`[i] ADMIN FUNCTION: Responder is ${isRunning ? 'active' : 'not active'} on ${hostIP}:${hostPort}`);
          break;
        case 'ipstat':
          printToTerminal(`[i] ADMIN FUNCTION: Responder is on ${hostIP}:${hostPort}`);
          break;
        case 'save':
          printToTerminal(`[!] ADMIN FUNCTION: Data saved as ${saveData}.`);
          printToTerminal(`[!] ADMIN FUNCTION: Data uploaded to: ${savePoint}.`);
          break;
        case 'script':
          printToTerminal(`[i] ADMIN FUNCTION: Scripts loaded: ${scripts}}`);
          break;
        /*case 'script=???':
          printToTerminal('[i] ADMIN FUNCTION: Running script - SCRIPT_NAME -');
          printToTerminal('[i] ADMIN FUNCTION: Result - RESULTS -');
          break;*/
        /*case 'YOUR_COMMAND':
          printToTerminal('PRINT_THIS_STATEMENT');
          printToTerminal(`PRINT THIS STATEMENT AND REFERENCE VARIABLE ${VARIABLE_HERE}'`);
          break;*/
          case 'clear':
          terminal.innerHTML = '';
          break;
          case 'wipe':
            printToTerminal('[!] ADMIN FUNCTION: Wiping trace data.');
            setTimeout(() => {
                printToTerminal('[!] ADMIN FUNCTION: Identifying...');
                setTimeout(() => {
                    printToTerminal('[!] ADMIN FUNCTION: Erasing...');
                    setTimeout(() => {
                    terminal.innerHTML = '';
                    isLocal = true;
                    terminal.classList.add('windows-prompt');
                    inputLine.classList.add('windows-mode');
                        printToTerminal('[!] ADMIN FUNCTION: Process purged.');
                        printToTerminal(' ... ');
                        printToTerminal('C:\\Windows\\System32> Unscheduled Runtime Error');
                        printToTerminal('C:\\Windows\\System32> System Restarting...');
                        printToTerminal('C:\\Windows\\System32> ');
                        inputLine.focus(); // Ensure focus is on input
                    }, 1000);
                }, 1000);
            }, 1000);
    break;

        default:
          printToTerminal(`[!] ADMIN FUNCTION: Unknown command - ${cmd}`);
      }
    }      

    // Input command handler
    inputLine.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
        const cmd = inputLine.value.trim();
        if (cmd) {
            handleCommand(cmd);
            inputLine.value = "";
            
            // In Windows mode, immediately show new prompt
            if (isLocal && cmd.toLowerCase() !== 'exit') {
                setTimeout(() => {
                    printToTerminal('C:\\Windows\\System32> ');
                }, 0);
            }
        }
    }
});

    let inCommandMode = false; // Tracks whether user is typing commands

    // Key-based log triggers
    document.addEventListener("keydown", (e) => {
    // --- Focus toggles --- (work in both modes)
    if (e.key === '/') {
        e.preventDefault();
        inputLine.focus();
        inCommandMode = true;
    }

    if (e.key === '.') {
        e.preventDefault();
        inputLine.blur();
        inCommandMode = false;
    }

    // --- Disable hotkeys in Windows mode ---
    if (isLocal) {
        // Allow normal typing in input line
        if (document.activeElement === inputLine) {
            return;
        }
        // Prevent default for number keys to avoid hotkey behavior
        if (['1','2'].includes(e.key)) {
            e.preventDefault();
        }
        return;
    }

    // --- Normal Responder mode hotkeys ---
    if (!inCommandMode) {
        if (e.key.toLowerCase() === 'w') {
            printToTerminal(warnLog);
        }
        if (e.key.toLowerCase() === 'b') {
            printToTerminal(beaconLog);
        }
        if (e.key.toLowerCase() === 'l') {
            const log = getRandomLog();
            printToTerminal(log);
        }
        if (e.key.toLowerCase() === 'p') {
            printToTerminal(specialLog);
        }
        if (e.key === '1') {
            printToTerminal(arpSpoofon);
        }
        if (e.key === '2') {
            printToTerminal(arpSpoofoff);
        }
    /*if (e.key.toLowerCase() === 'KEY') {
        printToTerminal(NAME OF CONSTANT);
    }*/
  }
});
  </script>
</body>
</html>